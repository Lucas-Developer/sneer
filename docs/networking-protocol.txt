Client Originates                              Server Replies
=================                              ==============

{:from own-puk}                                {}   (Ping/Pong - The server needs to know the client is online. The client needs to know if the server is up and needs to keep the outgoing UDP route open. One ping/pong every 20s means 258000 packets per month, so they should be as small as possible.)

{:from own-puk :send tuple :to puk}            {:ack tuple-id :for puk}
                                               or
                                               {:nak tuple-id :for puk}   (Server rejects (nak) the tuple if the send queue to puk is full.)


Client Replies                                 Server Originates
==============                                 =================

{:from own-puk :ack author-puk :id tuple-id}   {:send tuple}   (Tuple is being routed)

{:from own-puk :ack puk}                       {:cts puk}   (The send queue to puk became empty)


Server Implementation
=====================

; online-clients { puk { :pending-to-send  <tuple or cts-puk>
                         :online-countdown n             } }

Go loop [router, online-clients, send-round, offline-timer, send-timer] :priority :true
  <! packets-in
    when :from not online
      update-in online-clients [:from :pending-to-send (router peek))
    update-in online-clients [:from :online-countdown] 20

    match
      ping  - >! packets-out pong.
      :send - enqueue. >! packets-out ack or nak.
      :ack  - if (= tuple/cts (:from pending-out)) (assoc pending-out :from (router pop))

  <! offline-timer (5s)
    decrement online-countdown and purge offline entries from online-clients. Optimization: use an "online-round" number that is incremented at every purge instead of currentTimeMillis.

  >! packets-out (next-packet-to-send()) (if some)

  <! resend-timer (500ms)
    
